import os
from pathlib import Path
import xml.etree.ElementTree as ET
from typing import Dict

from PAOFLOW.DataController import DataController
import numpy as np

from PAOFLOW.transport.grid.rgrid import get_rgrid
from PAOFLOW.transport.io.input_parameters import AtomicProjData, ConductorData
import PAOFLOW.transport.io.log_module as log

from PAOFLOW.transport.io.write_data import (
    write_internal_format_files,
    write_projectability_files,
    write_overlap_files,
)
from PAOFLOW.transport.io.write_header import headered_function
from PAOFLOW.transport.parsers.atmproj_parser_base import (
    parse_eigenvalues,
    parse_header,
    parse_kpoints,
    parse_overlaps,
    parse_projections,
)
from PAOFLOW.transport.utils.timing import timed_function


def validate_proj_files(file_proj: str) -> str:
    """
    Ensure that both atomic_proj.xml and its companion data-file.xml exist.
    Returns the path to data-file-schema.xml if found.
    """
    savedir = os.path.dirname(file_proj)
    file_data = os.path.join(savedir, "data-file-schema.xml")
    if not os.path.exists(file_data):
        raise FileNotFoundError(f"Expected data-file-schema.xml at: {file_data}")
    return file_data


def convert_energy_units(proj_data: AtomicProjData) -> AtomicProjData:
    eigvals_raw = proj_data.eigvals.copy()
    efermi_raw = proj_data.efermi

    unit = proj_data.energy_units.lower()
    factors = {
        "ha": 27.211386018,
        "hartree": 27.211386018,
        "au": 27.211386018,
        "ry": 13.605693009,
        "ryd": 13.605693009,
        "rydberg": 13.605693009,
        "ev": 1.0,
        "electronvolt": 1.0,
    }
    if unit not in factors:
        raise ValueError(f"Unknown energy unit: {unit}")
    factor = factors[unit]

    return proj_data.model_copy(
        update={
            "eigvals_raw": eigvals_raw,
            "efermi_raw": efermi_raw,
            "eigvals": eigvals_raw * factor - efermi_raw * factor,
            "efermi": efermi_raw * factor,
        }
    )


@timed_function("atmproj_to_internal")
@headered_function("Conductor Initialization")
def parse_atomic_proj(
    data: ConductorData, data_controller: DataController
) -> Dict[str, np.ndarray]:
    file_proj = data.file_names.datafile_C
    output_dir = data.file_names.output_dir
    opts = data.atomic_proj

    arry, attr = data_controller.data_dicts()
    alat = attr["alat"]
    avec = arry["a_vectors"]
    bvec = arry["b_vectors"]

    lattice_data = {
        "alat": alat,
        "avec": avec,
        "bvec": bvec,
    }
    proj_data = parse_atomic_proj_xml(file_proj, lattice_data, data_controller)
    proj_data = convert_energy_units(proj_data)

    log.log_proj_summary(
        proj_data,
        data,
    )

    hk_data = get_pao_hamiltonian(data_controller)

    nk = np.array([1, 1, 4], dtype=int)  # TODO: confirm hardcoded grid
    nr = nk
    ivr, wr = get_rgrid(nr)
    hk_data.update({"ivr": ivr, "wr": wr, "nk": nk, "nr": nr})
    arry.update(hk_data)
    name = Path(file_proj).name
    output_prefix = Path(output_dir) / name
    write_internal_format_files(
        Path(output_dir),
        str(output_prefix),
        data_controller,
        hk_data,
        proj_data,
        opts.acbn0,
    )

    write_projectability_files(output_dir, proj_data, hk_data["Hk"])
    write_overlap_files(output_dir, hk_data["Sk"], opts.acbn0)

    return hk_data


def parse_atomic_proj_xml(
    file_proj: str, lattice_data: Dict, data_controller: DataController
) -> AtomicProjData:
    """
    Parse the Quantum ESPRESSO atomic_proj.xml file (from projwfc.x) into structured NumPy arrays.

    Parameters
    ----------
    file_proj : str
        Path to the atomic_proj.xml file generated by QE's projwfc.x. This XML file contains
        the bandstructure eigenvalues, k-point grid, projection data, and optionally, overlaps.
    lattice_data : dict
        Dictionary containing lattice parameters, including:
        - `alat` : float
            Lattice constant in Bohr.
        - `bvec` : (3, 3) ndarray
            Reciprocal lattice vectors in columns (Bohr^-1).

    Returns
    -------
    dict
        A dictionary containing:
        - `nbnds` : int
            Number of bands.
        - `nkpnts` : int
            Number of k-points.
        - `nspin` : int
            Number of spin components (1 for non-magnetic, 2 for collinear magnetic calculations).
        - `nawf` : int
            Number of atomic wavefunctions (projectors) in the system.
        - `nelec` : float
            Number of electrons in the system.
        - `efermi` : float
            Fermi energy in the units specified by `energy_units`.
        - `energy_units` : str
            Units of energy (e.g., 'eV', 'Ha', 'Ry') as specified in the XML file.
        - `kpts` : ndarray of shape (3, nkpnts)
            K-point coordinates in crystal units, transposed for consistency with PAOFLOW conventions.
        - `wk` : ndarray of shape (nkpnts,)
            K-point weights.
        - `eigvals` : ndarray of shape (nbnds, nkpnts, nspin)
            Eigenvalues of the bands at each k-point and spin.
        - `proj` : ndarray of shape (nawf, nbnds, nkpnts, nspin), complex
            Projection matrix elements ⟨atomic_wfc | Bloch_state⟩.
        - `overlap` : ndarray of shape (nawf, nawf, nkpnts, nspin), complex or None
            Overlap matrices S_{ij}(k) = ⟨atomic_wfc_i | atomic_wfc_j⟩ if present in the XML; else None.

    Notes
    -----
    The function performs the following steps:
    - Logs the start of eigenvalue and projection parsing.
    - Reads XML sections: HEADER, K-POINTS, WEIGHT_OF_K-POINTS, EIGENVALUES, PROJECTIONS, and optional OVERLAPS.
    - Supports both single and spin-polarized cases (1 or 2 spin channels).

    The projection matrix `proj` stores complex coefficients:
        `proj[ias, ib, ik, isp] = ⟨ atomic_wfc (ias) | Bloch_state (ib, ik, isp) ⟩`.

    The eigenvalues `eigvals` are:
        `eigvals[ib, ik, isp] = E_{ib}(k, spin)`, where `ib` is the band index.

    The overlap matrices `overlap` (if present) are:
        `overlap[i, j, ik, isp] = ⟨ atomic_wfc_i | atomic_wfc_j ⟩ at k-point ik, spin isp`.

    All arrays are stored in NumPy-friendly formats with dtype float64 or complex128.

    The XML structure parsed corresponds to QE's projwfc.x output:
    - HEADER block with general info.
    - K-POINTS and WEIGHT_OF_K-POINTS blocks.
    - EIGENVALUES and PROJECTIONS blocks, nested by k-points and optionally by spin.
    - OVERLAPS block if present.
    """

    header = parse_header(data_controller)
    kpt_data = parse_kpoints(lattice_data, data_controller)
    eigvals = parse_eigenvalues(data_controller)

    proj = parse_projections(data_controller)

    overlap = parse_overlaps(data_controller)

    return AtomicProjData(
        **header,
        **kpt_data,
        eigvals=eigvals,
        proj=proj,
        overlap=overlap,
    )


def get_pao_hamiltonian(data_controller: DataController) -> Dict[str, np.ndarray]:
    arry, attr = data_controller.data_dicts()
    Hks_raw = arry["Hks"]  # shape: (nawf, nawf, nk1, nk2, nk3, nspin)
    HRs_raw = arry["HRs"]  # shape: (nawf, nawf, nk1, nk2, nk3, nspin)
    nspin = attr["nspin"]
    nkpnts = attr["nkpnts"]
    nawf = attr["nawf"]
    acbn0 = attr["acbn0"]

    # reshape to (nawf, nawf, nkpnts, nspin)
    Hks_reshaped = Hks_raw.reshape((nawf, nawf, nkpnts, nspin))
    # transpose to (nspin, nkpnts, nawf, nawf)
    Hk = np.transpose(Hks_reshaped, (3, 2, 0, 1))

    HRs_reshaped = HRs_raw.reshape((nawf, nawf, nkpnts, nspin))
    HR = np.transpose(HRs_reshaped, (3, 2, 0, 1))

    Sks_raw = arry["Sks"] if "Sks" in arry else None
    Sk = Sks_raw.reshape((nawf, nawf, nkpnts, nspin)) if Sks_raw is not None else None

    SRs_raw = arry["SRs"] if "SRs" in arry else None
    SR = SRs_raw.reshape((nawf, nawf, nkpnts, nspin)) if SRs_raw is not None else None

    return {"Hk": Hk, "Sk": Sk, "HR": HR, "SR": SR}
