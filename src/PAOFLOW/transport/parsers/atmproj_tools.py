import os
from pathlib import Path
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Dict, Optional

from PAOFLOW import DataController
import numpy as np
from scipy.linalg import eigh, inv

from PAOFLOW.transport.grid.rgrid import get_rgrid
from PAOFLOW.transport.io.input_parameters import AtomicProjData, ConductorData
from PAOFLOW.transport.io.log_module import (
    log_proj_data,
    log_rank0,
    log_section_end,
    log_section_start,
)
from PAOFLOW.transport.io.write_data import (
    write_internal_format_files,
    write_projectability_files,
    write_overlap_files,
)
from PAOFLOW.transport.io.write_header import headered_function
from PAOFLOW.transport.parsers.atmproj_parser_base import (
    parse_eigenvalues,
    parse_header,
    parse_kpoints,
    parse_overlaps,
    parse_projections,
)
from PAOFLOW.transport.parsers.qexml import qexml_read_cell
from PAOFLOW.transport.utils.timing import timed_function


def validate_proj_files(file_proj: str) -> str:
    """
    Ensure that both atomic_proj.xml and its companion data-file.xml exist.
    Returns the path to data-file-schema.xml if found.
    """
    savedir = os.path.dirname(file_proj)
    file_data = os.path.join(savedir, "data-file-schema.xml")
    if not os.path.exists(file_data):
        raise FileNotFoundError(f"Expected data-file-schema.xml at: {file_data}")
    return file_data


def convert_energy_units(proj_data: AtomicProjData) -> AtomicProjData:
    eigvals_raw = proj_data.eigvals.copy()
    efermi_raw = proj_data.efermi

    unit = proj_data.energy_units.lower()
    factors = {
        "ha": 27.211386018,
        "hartree": 27.211386018,
        "au": 27.211386018,
        "ry": 13.605693009,
        "ryd": 13.605693009,
        "rydberg": 13.605693009,
        "ev": 1.0,
        "electronvolt": 1.0,
    }
    if unit not in factors:
        raise ValueError(f"Unknown energy unit: {unit}")
    factor = factors[unit]

    return proj_data.model_copy(
        update={
            "eigvals_raw": eigvals_raw,
            "efermi_raw": efermi_raw,
            "eigvals": eigvals_raw * factor - efermi_raw * factor,
            "efermi": efermi_raw * factor,
        }
    )


def log_proj_summary(proj_data: AtomicProjData, data: ConductorData) -> None:
    for line in log_proj_data(proj_data, data):
        log_rank0(line)


@timed_function("atmproj_to_internal")
@headered_function("Conductor Initialization")
def parse_atomic_proj(data: ConductorData, data_controller: DataController) -> Dict[str, np.ndarray]:
    file_proj = data.file_names.datafile_C
    output_dir = data.file_names.output_dir
    opts = data.atomic_proj

    file_data = validate_proj_files(file_proj)
    log_rank0(f"  {file_proj} file fmt: atmproj")

    arry, attr = data_controller.data_dicts()
    alat = attr["alat"]
    avec = arry["a_vectors"]
    bvec = arry["b_vectors"]

    lattice_data = {
        "alat": alat,
        "avec": avec,
        "bvec": bvec,
    }
    proj_data = parse_atomic_proj_xml(file_proj, lattice_data)
    proj_data = convert_energy_units(proj_data)

    log_proj_summary(
        proj_data,
        data,
    )

    log_section_start("atmproj_read_ext --massive data")
    hk_data = get_pao_hamiltonian(
        data_controller
    )
    log_section_end("atmproj_read_ext --massive data")

    nk = np.array([1, 1, 4], dtype=int)  # TODO: confirm hardcoded grid
    nr = nk
    ivr, wr = get_rgrid(nr)
    hk_data.update({"ivr": ivr, "wr": wr, "nk": nk, "nr": nr})

    name = Path(file_proj).name
    output_prefix = Path(output_dir) / name
    write_internal_format_files(
        Path(output_dir),
        str(output_prefix),
        hk_data,
        proj_data,
        lattice_data,
        opts.do_orthoovp,
    )

    write_projectability_files(output_dir, proj_data, hk_data["Hk"])
    write_overlap_files(output_dir, hk_data.get("S"), opts.do_orthoovp)

    log_rank0(f"{file_proj} converted from ATMPROJ to internal format")

    return hk_data


def parse_atomic_proj_xml(file_proj: str, lattice_data: Dict) -> AtomicProjData:
    """
    Parse the Quantum ESPRESSO atomic_proj.xml file (from projwfc.x) into structured NumPy arrays.

    Parameters
    ----------
    file_proj : str
        Path to the atomic_proj.xml file generated by QE's projwfc.x. This XML file contains
        the bandstructure eigenvalues, k-point grid, projection data, and optionally, overlaps.
    lattice_data : dict
        Dictionary containing lattice parameters, including:
        - `alat` : float
            Lattice constant in Bohr.
        - `bvec` : (3, 3) ndarray
            Reciprocal lattice vectors in columns (Bohr^-1).

    Returns
    -------
    dict
        A dictionary containing:
        - `nbnd` : int
            Number of bands.
        - `nkpts` : int
            Number of k-points.
        - `nspin` : int
            Number of spin components (1 for non-magnetic, 2 for collinear magnetic calculations).
        - `natomwfc` : int
            Number of atomic wavefunctions (projectors) in the system.
        - `nelec` : float
            Number of electrons in the system.
        - `efermi` : float
            Fermi energy in the units specified by `energy_units`.
        - `energy_units` : str
            Units of energy (e.g., 'eV', 'Ha', 'Ry') as specified in the XML file.
        - `kpts` : ndarray of shape (3, nkpts)
            K-point coordinates in crystal units, transposed for consistency with PAOFLOW conventions.
        - `wk` : ndarray of shape (nkpts,)
            K-point weights.
        - `eigvals` : ndarray of shape (nbnd, nkpts, nspin)
            Eigenvalues of the bands at each k-point and spin.
        - `proj` : ndarray of shape (natomwfc, nbnd, nkpts, nspin), complex
            Projection matrix elements ⟨atomic_wfc | Bloch_state⟩.
        - `overlap` : ndarray of shape (natomwfc, natomwfc, nkpts, nspin), complex or None
            Overlap matrices S_{ij}(k) = ⟨atomic_wfc_i | atomic_wfc_j⟩ if present in the XML; else None.

    Notes
    -----
    The function performs the following steps:
    - Logs the start of eigenvalue and projection parsing.
    - Reads XML sections: HEADER, K-POINTS, WEIGHT_OF_K-POINTS, EIGENVALUES, PROJECTIONS, and optional OVERLAPS.
    - Supports both single and spin-polarized cases (1 or 2 spin channels).

    The projection matrix `proj` stores complex coefficients:
        `proj[ias, ib, ik, isp] = ⟨ atomic_wfc (ias) | Bloch_state (ib, ik, isp) ⟩`.

    The eigenvalues `eigvals` are:
        `eigvals[ib, ik, isp] = E_{ib}(k, spin)`, where `ib` is the band index.

    The overlap matrices `overlap` (if present) are:
        `overlap[i, j, ik, isp] = ⟨ atomic_wfc_i | atomic_wfc_j ⟩ at k-point ik, spin isp`.

    All arrays are stored in NumPy-friendly formats with dtype float64 or complex128.

    The XML structure parsed corresponds to QE's projwfc.x output:
    - HEADER block with general info.
    - K-POINTS and WEIGHT_OF_K-POINTS blocks.
    - EIGENVALUES and PROJECTIONS blocks, nested by k-points and optionally by spin.
    - OVERLAPS block if present.
    """
    log_section_start("atmproj_read_ext")
    log_section_start("reading eigenvalues")

    tree = ET.parse(file_proj)
    root = tree.getroot()

    header = parse_header(root)
    kpt_data = parse_kpoints(root, lattice_data)
    eigvals = parse_eigenvalues(root, header["nbnd"], header["nkpts"], header["nspin"])

    log_section_end("reading eigenvalues")

    log_section_start("reading projections")
    proj = parse_projections(
        root, header["nbnd"], header["nkpts"], header["nspin"], header["natomwfc"]
    )

    log_section_end("reading projections")
    log_section_end("atmproj_read_ext")

    overlap = parse_overlaps(root, header["nkpts"], header["nspin"], header["natomwfc"])

    return AtomicProjData(
        **header,
        **kpt_data,
        eigvals=eigvals,
        proj=proj,
        overlap=overlap,
    )


def get_pao_hamiltonian( data_controller: DataController) -> Dict[str, np.ndarray]:

    arry,attr = data_controller.data_dicts()
    Hks_raw = arry["Hks"]  # shape: (nawf, nawf, nk1, nk2, nk3, nspin)
    nspin = attr['nspin']
    nkpts = attr['nkpts']
    nawf = attr['nawf']
    acbn0 = attr['acbn0']

    # reshape to (nawf, nawf, nkpts, nspin)
    Hks_reshaped = Hks_raw.reshape((nawf, nawf, nkpts, nspin))
    # transpose to (nspin, nkpts, nawf, nawf)
    Hk = np.transpose(Hks_reshaped, (3, 2, 0, 1))

    Sks_raw = arry["Sks"] if "Sks" in arry else None
    Sks_reshaped = Sks_raw.reshape((nawf, nawf, nkpts, nspin)) if Sks_raw is not None else None
    Sk = Sks_reshaped.copy() if acbn0 and Sks_reshaped is not None else None

    return {"Hk": Hk, "S": Sk}
