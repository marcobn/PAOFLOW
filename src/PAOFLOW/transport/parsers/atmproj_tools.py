import os
from pathlib import Path
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Dict, Optional

import numpy as np
from scipy.linalg import eigh, inv

from PAOFLOW.transport.grid.rgrid import get_rgrid
from PAOFLOW.transport.io.input_parameters import AtomicProjData, ConductorData
from PAOFLOW.transport.io.log_module import (
    log_proj_data,
    log_rank0,
    log_section_end,
    log_section_start,
)
from PAOFLOW.transport.io.write_data import (
    write_internal_format_files,
    write_projectability_files,
    write_overlap_files,
)
from PAOFLOW.transport.io.write_header import headered_function
from PAOFLOW.transport.parsers.atmproj_parser_base import (
    parse_eigenvalues,
    parse_header,
    parse_kpoints,
    parse_overlaps,
    parse_projections,
)
from PAOFLOW.transport.parsers.qexml import qexml_read_cell
from PAOFLOW.transport.utils.timing import timed_function


def validate_proj_files(file_proj: str) -> str:
    """
    Ensure that both atomic_proj.xml and its companion data-file.xml exist.
    Returns the path to data-file.xml if found.
    """
    savedir = os.path.dirname(file_proj)
    file_data = os.path.join(savedir, "data-file.xml")
    if not os.path.exists(file_data):
        raise FileNotFoundError(f"Expected data-file.xml at: {file_data}")
    return file_data


def convert_energy_units(proj_data: AtomicProjData) -> AtomicProjData:
    eigvals_raw = proj_data.eigvals.copy()
    efermi_raw = proj_data.efermi

    unit = proj_data.energy_units.lower()
    factors = {
        "ha": 27.211386018,
        "hartree": 27.211386018,
        "au": 27.211386018,
        "ry": 13.605693009,
        "ryd": 13.605693009,
        "rydberg": 13.605693009,
        "ev": 1.0,
        "electronvolt": 1.0,
    }
    if unit not in factors:
        raise ValueError(f"Unknown energy unit: {unit}")
    factor = factors[unit]

    return proj_data.model_copy(
        update={
            "eigvals_raw": eigvals_raw,
            "efermi_raw": efermi_raw,
            "eigvals": eigvals_raw * factor - efermi_raw * factor,
            "efermi": efermi_raw * factor,
        }
    )


def log_proj_summary(proj_data: AtomicProjData, data: ConductorData) -> None:
    for line in log_proj_data(proj_data, data):
        log_rank0(line)


@timed_function("atmproj_to_internal")
@headered_function("Conductor Initialization")
def parse_atomic_proj(data) -> Dict[str, np.ndarray]:
    file_proj = data.file_names.datafile_C
    output_dir = data.file_names.output_dir
    opts = data.atomic_proj

    file_data = validate_proj_files(file_proj)
    log_rank0(f"  {file_proj} file fmt: atmproj")

    lattice_data = qexml_read_cell(file_data)
    proj_data = parse_atomic_proj_xml(file_proj, lattice_data)
    proj_data = convert_energy_units(proj_data)

    log_proj_summary(
        proj_data,
        data,
    )

    log_section_start("atmproj_read_ext --massive data")
    hk_data = build_hamiltonian_from_proj(
        proj_data,
        data,
    )
    log_section_end("atmproj_read_ext --massive data")

    nk = np.array([1, 1, 4], dtype=int)  # TODO: confirm hardcoded grid
    nr = nk
    ivr, wr = get_rgrid(nr)
    hk_data.update({"ivr": ivr, "wr": wr, "nk": nk, "nr": nr})

    name = Path(file_proj).name
    output_prefix = Path(output_dir) / name
    write_internal_format_files(
        Path(output_dir),
        str(output_prefix),
        hk_data,
        proj_data,
        lattice_data,
        opts.do_orthoovp,
    )

    write_projectability_files(output_dir, proj_data, hk_data["Hk"])
    write_overlap_files(output_dir, hk_data.get("S"), opts.do_orthoovp)

    log_rank0(f"{file_proj} converted from ATMPROJ to internal format")

    return hk_data


def parse_atomic_proj_xml(file_proj: str, lattice_data: Dict) -> AtomicProjData:
    """
    Parse the Quantum ESPRESSO atomic_proj.xml file (from projwfc.x) into structured NumPy arrays.

    Parameters
    ----------
    file_proj : str
        Path to the atomic_proj.xml file generated by QE's projwfc.x. This XML file contains
        the bandstructure eigenvalues, k-point grid, projection data, and optionally, overlaps.
    lattice_data : dict
        Dictionary containing lattice parameters, including:
        - `alat` : float
            Lattice constant in Bohr.
        - `bvec` : (3, 3) ndarray
            Reciprocal lattice vectors in columns (Bohr^-1).

    Returns
    -------
    dict
        A dictionary containing:
        - `nbnd` : int
            Number of bands.
        - `nkpts` : int
            Number of k-points.
        - `nspin` : int
            Number of spin components (1 for non-magnetic, 2 for collinear magnetic calculations).
        - `natomwfc` : int
            Number of atomic wavefunctions (projectors) in the system.
        - `nelec` : float
            Number of electrons in the system.
        - `efermi` : float
            Fermi energy in the units specified by `energy_units`.
        - `energy_units` : str
            Units of energy (e.g., 'eV', 'Ha', 'Ry') as specified in the XML file.
        - `kpts` : ndarray of shape (3, nkpts)
            K-point coordinates in crystal units, transposed for consistency with PAOFLOW conventions.
        - `wk` : ndarray of shape (nkpts,)
            K-point weights.
        - `eigvals` : ndarray of shape (nbnd, nkpts, nspin)
            Eigenvalues of the bands at each k-point and spin.
        - `proj` : ndarray of shape (natomwfc, nbnd, nkpts, nspin), complex
            Projection matrix elements ⟨atomic_wfc | Bloch_state⟩.
        - `overlap` : ndarray of shape (natomwfc, natomwfc, nkpts, nspin), complex or None
            Overlap matrices S_{ij}(k) = ⟨atomic_wfc_i | atomic_wfc_j⟩ if present in the XML; else None.

    Notes
    -----
    The function performs the following steps:
    - Logs the start of eigenvalue and projection parsing.
    - Reads XML sections: HEADER, K-POINTS, WEIGHT_OF_K-POINTS, EIGENVALUES, PROJECTIONS, and optional OVERLAPS.
    - Supports both single and spin-polarized cases (1 or 2 spin channels).

    The projection matrix `proj` stores complex coefficients:
        `proj[ias, ib, ik, isp] = ⟨ atomic_wfc (ias) | Bloch_state (ib, ik, isp) ⟩`.

    The eigenvalues `eigvals` are:
        `eigvals[ib, ik, isp] = E_{ib}(k, spin)`, where `ib` is the band index.

    The overlap matrices `overlap` (if present) are:
        `overlap[i, j, ik, isp] = ⟨ atomic_wfc_i | atomic_wfc_j ⟩ at k-point ik, spin isp`.

    All arrays are stored in NumPy-friendly formats with dtype float64 or complex128.

    The XML structure parsed corresponds to QE's projwfc.x output:
    - HEADER block with general info.
    - K-POINTS and WEIGHT_OF_K-POINTS blocks.
    - EIGENVALUES and PROJECTIONS blocks, nested by k-points and optionally by spin.
    - OVERLAPS block if present.
    """
    log_section_start("atmproj_read_ext")
    log_section_start("reading eigenvalues")

    tree = ET.parse(file_proj)
    root = tree.getroot()

    header = parse_header(root)
    kpt_data = parse_kpoints(root, lattice_data)
    eigvals = parse_eigenvalues(root, header["nbnd"], header["nkpts"], header["nspin"])

    log_section_end("reading eigenvalues")

    log_section_start("reading projections")
    proj = parse_projections(
        root, header["nbnd"], header["nkpts"], header["nspin"], header["natomwfc"]
    )

    log_section_end("reading projections")
    log_section_end("atmproj_read_ext")

    overlap = parse_overlaps(root, header["nkpts"], header["nspin"], header["natomwfc"])

    return AtomicProjData(
        **header,
        **kpt_data,
        eigvals=eigvals,
        proj=proj,
        overlap=overlap,
    )


def build_hamiltonian_from_proj(
    proj_data: AtomicProjData,
    data: ConductorData,
) -> Dict[str, np.ndarray]:
    """
    Construct H(k) from projection data.

    Parameters
    ----------
    `proj_data` : Dict
        Output from parse_atomic_proj_xml.
    `atmproj_sh` : float
        Energy shift used as a band filter.
    `atmproj_thr` : float
        Minimum projector weight to include a band.
    `atmproj_nbnd` : int or None
        Maximum number of bands to include.
    `do_orthoovp` : bool
        If False, include the non-orthogonal overlaps. If True, projector basis has been orthonormalized.
    `atmproj_do_norm` : bool
        If True, normalize the projectors.
    `shifting_scheme` : int
        1 = direct sum over projectors; 2 = projected subspace with inverse PA

    Returns
    -------
    Dict[str, np.ndarray]
        Includes keys:
        - 'Hk': complex ndarray, shape (nspin, nkpts, natomwfc, natomwfc)
        - 'S' : complex ndarray, shape (natomwfc, natomwfc, nkpts, nspin) if available

    Notes
    -----
    Two schemes are used for constructing the k-dependent Hamiltonian:

    1. **Shifting scheme 1 (default):**

       The Hamiltonian is constructed from the outer product of the projectors:

           H(k) = ∑_b [eig_b(k) - κ] · |proj_b(k)><proj_b(k)|

       where the summation runs over bands b with eigenvalues below `atmproj_sh` κ.
       Optional projector normalization is applied before the outer product.

    2. **Shifting scheme 2 (subspace projection):**

       Let A be the matrix whose columns are selected projectors for eigenvalues < κ:

           A_{i b} = <ϕ_i | ψ_b>

       Let E be a diagonal matrix with corresponding eigenvalues:

           E_{bb} = eig_b(k)

       Define the projector overlap:

           PA = A⁺ · A

       Compute its inverse, IPA = (A⁺ A)⁻¹. Then construct:

           H_aux = (E - κ IPA) · A⁺
           H(k) = A · H_aux = A · (E - κ IPA) · A⁺

       This is a more accurate low-rank projection of the Hamiltonian into the atomic subspace.

    In both cases, a final shift of +κ is added to the Hamiltonian either as:
    - H(k) += κ · S(k) for non-orthogonal basis
    - H(k) += κ · I for orthonormal basis

    If `do_orthoovp` is False, an additional transformation is applied:
        H(k) -> S(k)½ · H(k) · S(k)½
    where S(k)½ is the square root of the overlap matrix.
    """
    eig = proj_data.eigvals
    proj = proj_data.proj
    S_raw = proj_data.overlap

    nbnd = proj_data.nbnd
    nkpts = proj_data.nkpts
    nspin = proj_data.nspin
    natomwfc = proj_data.natomwfc

    opts = HamiltonianOptions(
        sh=data.atomic_proj.atmproj_sh,
        thr=data.atomic_proj.atmproj_thr,
        nbnd=data.atomic_proj.atmproj_nbnd,
        do_norm=data.atomic_proj.atmproj_do_norm,
        do_orthoovp=data.atomic_proj.do_orthoovp,
        shifting_scheme=data.advanced.shifting_scheme,
    )

    atmproj_nbnd_ = (
        min(data.atomic_proj.atmproj_nbnd, nbnd)
        if data.atomic_proj.atmproj_nbnd and data.atomic_proj.atmproj_nbnd > 0
        else nbnd
    )
    Hk = np.zeros((nspin, nkpts, natomwfc, natomwfc), dtype=np.complex128)
    Sk = S_raw.copy() if not opts.do_orthoovp and S_raw is not None else None

    for isp in range(nspin):
        for ik in range(nkpts):
            if opts.shifting_scheme == 2:
                H = build_scheme2(eig, proj, ik, isp, opts)
            else:
                H = build_scheme1(eig, proj, ik, isp, opts, atmproj_nbnd_, natomwfc)

            if not opts.do_orthoovp and S_raw is not None:
                H = apply_overlap_transformation(H, S_raw[:, :, ik, isp])

            if not opts.do_orthoovp and S_raw is not None:
                H += opts.sh * S_raw[:, :, ik, isp]
            else:
                H += opts.sh * np.eye(natomwfc, dtype=np.complex128)

            enforce_hermiticity(H, opts.hermitian_tol, ik, isp)
            Hk[isp, ik] = H

    return {"Hk": Hk, "S": Sk}


@dataclass
class HamiltonianOptions:
    sh: float
    thr: float
    nbnd: Optional[int]
    do_norm: bool
    do_orthoovp: bool
    shifting_scheme: int = 1
    hermitian_tol: float = 1e-8


def build_scheme1(
    eig: np.ndarray,
    proj: np.ndarray,
    ik: int,
    isp: int,
    opts: HamiltonianOptions,
    atmproj_nbnd: int,
    natomwfc: int,
) -> np.ndarray:
    """
    Construct H(k) using scheme 1 (direct projector outer product).

    Notes
    -----
    Matches Fortran `atmproj_to_internal` behavior:
    - If `thr > 0.0`, only eigenvalue filtering is applied (`energy > sh`).
      The projector weight filter present in older versions is commented
      out in the Fortran code and is therefore disabled here.
    - If `thr <= 0.0`, only eigenvalue filtering is applied as well.
    - Normalization is applied if `do_norm` is True and weight > 1e-14.
    """
    H = np.zeros((natomwfc, natomwfc), dtype=np.complex128)
    for ib in range(atmproj_nbnd):
        energy = eig[ib, ik, isp]
        proj_b = proj[:, ib, ik, isp]
        weight = np.vdot(proj_b, proj_b).real

        if opts.thr > 0.0:
            if energy > opts.sh:
                continue
        else:
            if energy >= opts.sh:
                continue

        if opts.do_norm and weight > 1e-14:
            proj_b = proj_b / np.sqrt(weight)

        H += (energy - opts.sh) * np.outer(proj_b, proj_b.conj())

        H = 0.5 * (H + H.conj().T)
    return H.T


def build_scheme2(
    eig: np.ndarray,
    proj: np.ndarray,
    ik: int,
    isp: int,
    opts: HamiltonianOptions,
) -> np.ndarray:
    """
    Construct H(k) using scheme 2 (subspace projection).

    Notes
    -----
    Matches Fortran `atmproj_to_internal` behavior:
    - Selects only eigenvalues below the shift (`eig < sh`).
    - Projector weight (`proj_wgt`) is always computed, even though
      filtering is based only on eigenvalues.
    - Normalization is applied if `do_norm` is True and weight > 1e-14.
    """
    mask = [ib for ib in range(eig.shape[0]) if eig[ib, ik, isp] < opts.sh]
    if not mask:
        raise RuntimeError(f"No eigenvalues below shift at ik={ik}")

    E = np.diag(eig[mask, ik, isp])
    A = proj[:, mask, ik, isp].copy()

    for ib in range(A.shape[1]):
        weight = np.vdot(A[:, ib], A[:, ib]).real
        if opts.do_norm and weight > 1e-14:
            A[:, ib] /= np.sqrt(weight)

    PA = A.conj().T @ A
    IPA = inv(PA)
    H_aux = (E - opts.sh * IPA) @ A.conj().T
    H = A @ H_aux
    H = 0.5 * (H + H.conj().T)
    return H.T


def apply_overlap_transformation(H: np.ndarray, S: np.ndarray) -> np.ndarray:
    w, U = eigh(S)
    if np.any(w <= 0):
        raise ValueError("Negative or zero overlap eigenvalue")
    sqrtS = U @ np.diag(np.sqrt(w)) @ U.conj().T
    return sqrtS @ H @ sqrtS.conj().T


def enforce_hermiticity(H: np.ndarray, tol: float, ik: int, isp: int) -> None:
    if not np.allclose(H, H.conj().T, atol=tol):
        raise ValueError(f"H(k) not Hermitian at ik={ik}, isp={isp}")
